import { Component, OnInit } from '@angular/core';
import { CommonModule } from '@angular/common';
import { FormsModule } from '@angular/forms';
import { PaymentService } from '../../services/payment.service';
import { Payment } from '../../models/payment.model';

@Component({
  standalone: true,
  selector: 'app-payment',
  imports: [CommonModule, FormsModule],
  templateUrl: './payment.component.html',
  styleUrls: ['./payment.component.css']
})
export class PaymentComponent implements OnInit {
  payments: Payment[] = [];
  newPayment: Payment = {
    id: undefined, // Optional ID since it's generated by the backend
    amount: 0,
    method: '',
    status: 'pending',
    date: new Date().toISOString().split('T')[0]
  };
  selectedPayment?: Payment;
  isLoading = false;
  errorMessage: string | null = null;

  constructor(private paymentService: PaymentService) {}

  ngOnInit(): void {
    this.loadPayments();
  }

  loadPayments(): void {
    this.isLoading = true;
    this.errorMessage = null;
    
    this.paymentService.getAll().subscribe({
      next: (data) => {
        this.payments = data;
        this.isLoading = false;
      },
      error: (err) => {
        console.error('Failed to load payments:', err);
        this.errorMessage = 'Unable to connect to the backend service.';
        this.isLoading = false;
      }
    });
  }

  addPayment(): void {
    if (!this.validatePayment(this.newPayment)) return;

    this.isLoading = true;
    this.paymentService.create(this.newPayment).subscribe({
      next: () => {
        this.loadPayments();
        this.resetForm();
      },
      error: (err) => {
        console.error('Failed to create payment:', err);
        this.errorMessage = 'Failed to create payment. Please check your data.';
        this.isLoading = false;
      }
    });
  }

  selectPayment(payment: Payment): void {
    this.selectedPayment = { ...payment };
  }

  updatePayment(): void {
    if (!this.selectedPayment || this.selectedPayment.id === undefined) {
      this.errorMessage = 'Cannot update payment without a valid ID.';
      return;
    }
  
    if (!this.validatePayment(this.selectedPayment)) return;
  
    this.isLoading = true;
    this.paymentService.update(this.selectedPayment.id, this.selectedPayment).subscribe({
      next: () => {
        this.loadPayments();
        this.selectedPayment = undefined;
      },
      error: (err) => {
        console.error('Failed to update payment:', err);
        this.errorMessage = 'Failed to update payment. Please try again.';
        this.isLoading = false;
      }
    });
  }

  deletePayment(id: number | undefined): void {
    if (id === undefined) {
      this.errorMessage = 'Payment ID is undefined!';
      return;
    }
  
    if (!confirm('Are you sure you want to delete this payment?')) return;
  
    this.isLoading = true;
    this.paymentService.delete(id).subscribe({
      next: () => {
        this.loadPayments();
      },
      error: (err) => {
        console.error('Failed to delete payment:', err);
        this.errorMessage = 'Failed to delete payment. Please try again.';
        this.isLoading = false;
      }
    });
  }
  

  private validatePayment(payment: Payment): boolean {
    if (!payment.amount || payment.amount <= 0) {
      this.errorMessage = 'Amount must be greater than 0';
      return false;
    }
    if (!payment.method || !payment.status) {
      this.errorMessage = 'Method and status are required';
      return false;
    }
    this.errorMessage = null;
    return true;
  }

  private resetForm(): void {
    this.newPayment = {
      id: undefined, // Resetting ID for new payment
      amount: 0,
      method: '',
      status: 'pending',
      date: new Date().toISOString().split('T')[0]
    };
  }

  getStatusClass(status: string): string {
    switch (status.toLowerCase()) {
      case 'completed': return 'success';
      case 'pending': return 'warning';
      case 'failed': return 'danger';
      default: return 'secondary';
    }
  }
}
